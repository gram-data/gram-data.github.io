(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{Ecu8:function(e,t,n){"use strict";var a=n("q1tI"),l=n.n(a),r=n("Oy/b"),c=n.n(r);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var m=Object(a.memo)((function(e){var t=e.children,n=e.math,r=e.block,m=e.errorColor,u=e.renderError,i=e.settings,d=e.as,E=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t.indexOf(n=r[a])>=0||(l[n]=e[n]);return l}(e,["children","math","block","errorColor","renderError","settings","as"]),h=d||(r?"div":"span"),s=null!=t?t:n,p=Object(a.useState)({innerHtml:""}),b=p[0],g=p[1];return Object(a.useEffect)((function(){try{var e=c.a.renderToString(s,o({displayMode:!!r,errorColor:m,throwOnError:!!u},i));g({innerHtml:e})}catch(e){if(!(e instanceof c.a.ParseError||e instanceof TypeError))throw e;g(u?{errorElement:u(e)}:{innerHtml:e.message})}}),[r,s,m,u,i]),"errorElement"in b?b.errorElement:l.a.createElement(h,Object.assign({},E,{dangerouslySetInnerHTML:{__html:b.innerHtml}}))}));t.a=m},Fs4X:function(e,t,n){"use strict";n.r(t);var a=n("q1tI"),l=n.n(a),r=n("9Dj+"),c=n("vrFN"),o=(n("vg9a"),n("Ecu8")),m=n("lPbZ");t.default=function(){return l.a.createElement(r.a,null,l.a.createElement(c.a,{title:"Graph Path Math"}),l.a.createElement(m.b.h1,null,"Graph Path Math"),l.a.createElement("p",null,"Everything is a Path. Structure builds up by composing empty Paths into non-empty Paths."),l.a.createElement(m.b.h2,null,"Type Definitions"),l.a.createElement("p",null,"(The notation here borrows from Purescript.)"),l.a.createElement(m.b.h3,null,"Paths"),l.a.createElement("p",null,"Paths are either empty or the composition of two paths."),l.a.createElement("dl",null,l.a.createElement("dt",null,l.a.createElement(m.b.code,null,"data Path = empty | path (Path) (Path) ")),l.a.createElement("dd",null,l.a.createElement(m.b.code,null,"empty :: Path")),l.a.createElement("dd",null,l.a.createElement(m.b.code,null,"path :: Path --\x3e Path --\x3e Path"))),l.a.createElement(m.b.h3,null,"Graph elements"),l.a.createElement("p",null,"Graph elements are special cases of a Path."),l.a.createElement("p",null,"A Node is a Path of length 0 containing two empty Paths."),l.a.createElement("dl",null,l.a.createElement("dt",null,l.a.createElement(m.b.code,null,"type Node = Path")),l.a.createElement("dd",null,l.a.createElement(m.b.code,null,"node :: Empty --\x3e Empty --\x3e Node"))),l.a.createElement("p",null,"An Edge is a Path of length 1 containing two Nodes."),l.a.createElement("dl",null,l.a.createElement("dt",null,l.a.createElement(m.b.code,null,"type Edge = Path")),l.a.createElement("dd",null,l.a.createElement(m.b.code,null,"edge :: Node --\x3e Node --\x3e Edge"))),l.a.createElement(m.b.h3,null,"Path sequence"),l.a.createElement("p",null,"A PathSequence is an ordered, lazy composition of Paths. The elements are composed pairwise to produce the final Path representation. The order of pairing is left-to-right."),l.a.createElement("dl",null,l.a.createElement("dt",null,l.a.createElement(m.b.code,null,"type PathSequence = List Path")),l.a.createElement("dd",null,l.a.createElement(m.b.code,null,"foldPath :: PathSequence --\x3e Path"))),l.a.createElement(m.b.h3,null,"Graphs"),l.a.createElement("p",null,"The classic graph ",l.a.createElement(m.b.code,null,"ùîæ = (ùïç, ùîº)")," is derived from Paths. Both nodes and edges may occur multiple times within a path. The order of appearance within a Path represents a sort of additive history for the graph elements. Record values and labels are merged forward."),l.a.createElement("dl",null,l.a.createElement("dt",null,l.a.createElement(m.b.code,null,"type NodeSet = List Node")),l.a.createElement("dd",null,l.a.createElement(m.b.code,null,"nodes :: Path --\x3e List Node"))),l.a.createElement("dl",null,l.a.createElement("dt",null,l.a.createElement(m.b.code,null,"type EdgeSet = List Edge")),l.a.createElement("dd",null,l.a.createElement(m.b.code,null,"edges :: Path --\x3e List Edge"))),l.a.createElement("dl",null,l.a.createElement("dt",null,l.a.createElement(m.b.code,null,"type Graph = { nodes :: NodeSet, edges :: EdgeSet }"))),l.a.createElement(m.b.h2,null,"Path Notation"),l.a.createElement("p",null,"Gram uses two complementary notations for paths:"),l.a.createElement("ol",null,l.a.createElement("li",null,"Cypher path: alternating nodes and edges"),l.a.createElement("li",null,"Path composition: two paths composed into a new path")),l.a.createElement("p",null,"Both notations use the following relations:"),l.a.createElement("ul",null,l.a.createElement("li",null,l.a.createElement(m.b.code,null,"<--")," oriented to the left"),l.a.createElement("li",null,l.a.createElement(m.b.code,null,"--\x3e")," oriented to the right"),l.a.createElement("li",null,l.a.createElement(m.b.code,null,"‚Äî‚Äî")," oriented in either direction"),l.a.createElement("li",null,l.a.createElement(o.a,null,"\\large{,}")," pairwise association")),l.a.createElement(m.b.table,null,l.a.createElement("tbody",null,l.a.createElement(m.b.tr,null,l.a.createElement("th",null),l.a.createElement(m.b.th,null,"Empty"),l.a.createElement(m.b.th,null,"Node"),l.a.createElement(m.b.th,null,"Edge"),l.a.createElement(m.b.th,null,"Path")),l.a.createElement(m.b.tr,null,l.a.createElement(m.b.th,null,"Cypher path"),l.a.createElement(m.b.td,null,l.a.createElement(o.a,null," ")),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"(n)")),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"(n1)-[e]->(n2)")),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"p = ()--\x3e(),()<--()"))),l.a.createElement(m.b.tr,null,l.a.createElement(m.b.th,null,"Path composition"),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"√∏¬†=¬†[¬†]")),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"[n √∏ √∏]")),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"[e --\x3e n1 n2]")),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"[p , p1 p2]"))))),l.a.createElement("p",null,"Cypher path notation is easier to read. Path composition is harder to read. The notation can be mixed to annotate information about a cypher path. These three notations are equivalent:"),l.a.createElement(m.b.table,null,l.a.createElement("tbody",null,l.a.createElement(m.b.tr,null,l.a.createElement(m.b.th,null,"Cypher path"),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"p = (n1)-[e1]->(n2)<-[e2]-(n3)"))),l.a.createElement(m.b.tr,null,l.a.createElement(m.b.th,null,"Path composition"),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"[p [e1 --\x3e n1 [e2 <-- n2 n3] ] ]"))),l.a.createElement(m.b.tr,null,l.a.createElement(m.b.th,null,"Mixed notation"),l.a.createElement(m.b.td,null,l.a.createElement(m.b.code,null,"[p (n1)-[e1]->(n2)<-[e2]-(n3)]"))))))}},vg9a:function(e,t,n){},vrFN:function(e,t,n){"use strict";var a=n("q1tI"),l=n.n(a),r=n("qhky"),c=n("Wbzz");function o(e){var t=e.description,n=e.lang,a=e.meta,o=e.title,m=Object(c.useStaticQuery)("63159454").site,u=t||m.siteMetadata.description;return l.a.createElement(r.a,{htmlAttributes:{lang:n},title:o,titleTemplate:"%s | "+m.siteMetadata.title,meta:[{name:"description",content:u},{property:"og:title",content:o},{property:"og:description",content:u},{property:"og:type",content:"website"},{name:"twitter:card",content:"summary"},{name:"twitter:creator",content:m.siteMetadata.author},{name:"twitter:title",content:o},{name:"twitter:description",content:u}].concat(a)})}o.defaultProps={lang:"en",meta:[],description:""},t.a=o}}]);
//# sourceMappingURL=component---src-pages-math-tsx-d3257e4b8cdd4adbf115.js.map