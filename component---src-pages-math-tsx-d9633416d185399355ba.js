(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{Ecu8:function(e,t,l){"use strict";var a=l("q1tI"),n=l.n(a),r=l("Oy/b"),c=l.n(r);function m(){return(m=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var l=arguments[t];for(var a in l)Object.prototype.hasOwnProperty.call(l,a)&&(e[a]=l[a])}return e}).apply(this,arguments)}var u=Object(a.memo)((function(e){var t=e.children,l=e.math,r=e.block,u=e.errorColor,o=e.renderError,i=e.settings,E=e.as,d=function(e,t){if(null==e)return{};var l,a,n={},r=Object.keys(e);for(a=0;a<r.length;a++)t.indexOf(l=r[a])>=0||(n[l]=e[l]);return n}(e,["children","math","block","errorColor","renderError","settings","as"]),s=E||(r?"div":"span"),h=null!=t?t:l,p=Object(a.useState)({innerHtml:""}),b=p[0],f=p[1];return Object(a.useEffect)((function(){try{var e=c.a.renderToString(h,m({displayMode:!!r,errorColor:u,throwOnError:!!o},i));f({innerHtml:e})}catch(e){if(!(e instanceof c.a.ParseError||e instanceof TypeError))throw e;f(o?{errorElement:o(e)}:{innerHtml:e.message})}}),[r,h,u,o,i]),"errorElement"in b?b.errorElement:n.a.createElement(s,Object.assign({},d,{dangerouslySetInnerHTML:{__html:b.innerHtml}}))}));t.a=u},Fs4X:function(e,t,l){"use strict";l.r(t);var a=l("q1tI"),n=l.n(a),r=l("9Dj+"),c=l("vrFN"),m=(l("vg9a"),l("Ecu8")),u=l("lPbZ");t.default=function(){return n.a.createElement(r.a,null,n.a.createElement(c.a,{title:"Graph Path Math"}),n.a.createElement(u.b.h1,null,"Graph Path Math"),n.a.createElement("p",null,"Gram structures data as ",n.a.createElement("a",{href:"https://neo4j.com/developer/graph-database/"},"property graph")," paths. What are the formal semantics of composing a graph? Let's start with the types of the things..."),n.a.createElement(u.b.h2,null,"Type Definitions"),n.a.createElement("p",null,"The notation here borrows from Purescript."),n.a.createElement(u.b.h3,null,"Paths"),n.a.createElement("p",null,"Paths are either empty or the composition of two paths."),n.a.createElement("dl",null,n.a.createElement("dt",null,n.a.createElement(u.b.code,null,"data Path = empty | path (Path) (Path) ")),n.a.createElement("dd",null,n.a.createElement(u.b.code,null,"empty :: Path")),n.a.createElement("dd",null,n.a.createElement(u.b.code,null,"path :: Path --\x3e Path --\x3e Path"))),n.a.createElement(u.b.h3,null,"Graph elements"),n.a.createElement("p",null,"Graph elements are special cases of a Path."),n.a.createElement("p",null,"A Node is a Path of length 0 containing two empty Paths."),n.a.createElement("dl",null,n.a.createElement("dt",null,n.a.createElement(u.b.code,null,"type Node = Path")),n.a.createElement("dd",null,n.a.createElement(u.b.code,null,"node :: Empty --\x3e Empty --\x3e Node"))),n.a.createElement("p",null,"An Edge is a Path of length 1 containing two Nodes."),n.a.createElement("dl",null,n.a.createElement("dt",null,n.a.createElement(u.b.code,null,"type Edge = Path")),n.a.createElement("dd",null,n.a.createElement(u.b.code,null,"edge :: Node --\x3e Node --\x3e Edge"))),n.a.createElement(u.b.h3,null,"Path sequence"),n.a.createElement("p",null,"A PathSequence is a Path-like lazy composition of Paths represented as a list. The list elements should be composed pairwise to produce the final Path representation. The order of pairing is left-to-right."),n.a.createElement("dl",null,n.a.createElement("dt",null,n.a.createElement(u.b.code,null,"type PathSequence = List Path"))),n.a.createElement(u.b.h3,null,"Graphs"),n.a.createElement("p",null,"The classic graph ",n.a.createElement(u.b.code,null,"ùîæ = (ùïç, ùîº)")," is derived from Paths. Both nodes and edges may occur multiple times within a path. The order of appearance within a PathSequence and then individual paths represents a sort of additive history for the graph elements. Record values and labels are merged forward"),n.a.createElement("dl",null,n.a.createElement("dt",null,n.a.createElement(u.b.code,null,"type NodeSet = List Node")),n.a.createElement("dd",null,n.a.createElement(u.b.code,null,"nodes :: Path --\x3e List Node"))),n.a.createElement("dl",null,n.a.createElement("dt",null,n.a.createElement(u.b.code,null,"type EdgeSet = List Edge")),n.a.createElement("dd",null,n.a.createElement(u.b.code,null,"edges :: Path --\x3e List Edge"))),n.a.createElement("dl",null,n.a.createElement("dt",null,n.a.createElement(u.b.code,null,"type Graph = { nodes :: NodeSet, edges :: EdgeSet }"))),n.a.createElement(u.b.h2,null,"Path Elements"),n.a.createElement(u.b.table,null,n.a.createElement("tbody",null,n.a.createElement(u.b.tr,null,n.a.createElement("th",null),n.a.createElement(u.b.th,null,"Empty"),n.a.createElement(u.b.th,null,"Node"),n.a.createElement(u.b.th,null,"Edge"),n.a.createElement(u.b.th,null,"Path")),n.a.createElement(u.b.tr,null,n.a.createElement(u.b.th,null,n.a.createElement(m.a,null,"ùïå = \\lbrace n, e, p \\rbrace")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"\\empty ")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"n \\isin ‚Ñï")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"e \\isin ùîº")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"p \\isin ‚Ñô"))),n.a.createElement(u.b.tr,null,n.a.createElement(u.b.th,null,"Path Notation"),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[ ] \\equiv \\empty ")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[n]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[e] \\equiv [e [n,n']]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[p] \\equiv [p  [ ùïå ] ] \\equiv [p [ùïå, ùïå']]"))),n.a.createElement(u.b.tr,null,n.a.createElement(u.b.th,null,"Gram Notation"),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[ ] ")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"(n)")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"(n)\\text{--}[e]\\text{--}(n')")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[p] \\\\\n          [p (n)]\\\\\n          [p ()-[e]-()]"))),n.a.createElement(u.b.tr,null,n.a.createElement(u.b.th,null,"Relation Operators ",n.a.createElement("br",null),n.a.createElement(m.a,null,"\\sim = \\lbrace \\leftarrow, \\rightarrow, \\text{---}, \\huge{,}\\normalsize\\rbrace ")),n.a.createElement(u.b.td,null),n.a.createElement(u.b.td,null),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"\\text{\\footnotesize{\\textquotedblleft left\\textquotedblright}} \\leftarrow \\\\\n          \\text{\\footnotesize{\\textquotedblleft right\\textquotedblright}} \\rightarrow \\\\\n          \\text{\\footnotesize{\\textquotedblleft either\\textquotedblright}} \\text{---}\n          ")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"\\text{\\footnotesize{\\textquotedblleft left\\textquotedblright}} \\leftarrow \\\\\n          \\text{\\footnotesize{\\textquotedblleft right\\textquotedblright}} \\rightarrow \\\\\n          \\text{\\footnotesize{\\textquotedblleft either\\textquotedblright}} \\text{---} \\\\\n          \\text{\\footnotesize{\\textquotedblleft pair\\textquotedblright}} \\huge{,}\\normalsize\n          "))))),n.a.createElement(u.b.h2,null,"Path Composition"),n.a.createElement("table",null,n.a.createElement("tbody",null,n.a.createElement("tr",null,n.a.createElement("td",null),n.a.createElement(u.b.th,null,"Empty"),n.a.createElement(u.b.th,null,"Node"),n.a.createElement(u.b.th,null,"Edge"),n.a.createElement(u.b.th,null,"Path")),n.a.createElement("tr",null,n.a.createElement(u.b.th,null,"Empty"),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"\\empty \\sim \\empty \\equiv \\empty")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"\\empty \\sim [n] \\equiv [n]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"\\empty \\sim [e] \\equiv [e]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"\\empty \\sim [p] \\equiv [p]"))),n.a.createElement("tr",null,n.a.createElement(u.b.th,null,"Node"),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[n] \\sim \\empty \\equiv [n]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[n] \\sim [n] \\equiv [e]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[n] \\sim [e] \\equiv [p]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[n] \\sim [p] \\equiv [p']"))),n.a.createElement("tr",null,n.a.createElement(u.b.th,null,"Edge"),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[e] \\sim \\empty \\equiv [e]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[e] \\sim [n] \\equiv [p]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[e] \\sim [e] \\equiv [e]")),n.a.createElement(u.b.td,null,n.a.createElement(m.a,null,"[e] \\sim [p] \\equiv [p]"))))))}},vg9a:function(e,t,l){},vrFN:function(e,t,l){"use strict";var a=l("q1tI"),n=l.n(a),r=l("qhky"),c=l("Wbzz");function m(e){var t=e.description,l=e.lang,a=e.meta,m=e.title,u=Object(c.useStaticQuery)("63159454").site,o=t||u.siteMetadata.description;return n.a.createElement(r.a,{htmlAttributes:{lang:l},title:m,titleTemplate:"%s | "+u.siteMetadata.title,meta:[{name:"description",content:o},{property:"og:title",content:m},{property:"og:description",content:o},{property:"og:type",content:"website"},{name:"twitter:card",content:"summary"},{name:"twitter:creator",content:u.siteMetadata.author},{name:"twitter:title",content:m},{name:"twitter:description",content:o}].concat(a)})}m.defaultProps={lang:"en",meta:[],description:""},t.a=m}}]);
//# sourceMappingURL=component---src-pages-math-tsx-d9633416d185399355ba.js.map